import java.util.stream.Stream
import java.util.regex.Pattern
import java.nio.file.Paths
import java.nio.file.Files

plugins {
    // Project Type
    id "cpp-library"
    // IDEs
    id "visual-studio"
    // Code Formatter
    id "com.diffplug.gradle.spotless" version "4.0.1"
}

library {
    linkage = [Linkage.STATIC, Linkage.SHARED]
    
    source.from file('src')
    publicHeaders.from file('src')
    //privateHeaders.from file('src')
    //publicHeaders.from file('include')
    
    binaries.configureEach {
        def compTask     = compileTask.get()
        def compilerArgs = compTask.compilerArgs
        def macros       = compTask.macros

        if (toolChain in Gcc) {
            compilerArgs.addAll "-std=c++1z", "-Wall", "-Wextra", "-Wpedantic", "-fPIC"
        }
        if (toolChain in Clang) {
            compilerArgs.addAll "-std=c++1z", "-Weverything", "-pedantic"
        }
        if (toolChain in VisualCpp) {
            compilerArgs.addAll "/std:c++17", "/W4", "/FS", "/EHsc"
        }

        if (optimized) {
            macros.put("__NDEBUG__", null)

            if (toolChain in Gcc) {
                compilerArgs.addAll "-Ofast", "-g0"
            }
            if (toolChain in Clang) {
                compilerArgs.addAll "-Ofast", "-g0"
            }
            if (toolChain in VisualCpp) {
                compilerArgs.addAll "/O2"
            }
        } else {
            macros.put("__DEBUG__", null)

            if (toolChain in Gcc) {
                compilerArgs.addAll "-Og", "-g3"
            }
            if (toolChain in Clang) {
                compilerArgs.addAll "-O0", "-g"
            }
            if (toolChain in VisualCpp) {
                compilerArgs.addAll "/Od", "/Z7"
            }
        }
    }
}

spotless {
    cpp {
        eclipse().configFile "TGUI-Code-Format.xml"

        licenseHeaderFile "LICENSE-header.txt", "#"
    }
}

task doc {
    dependsOn "generateHTMLdoc"
    dependsOn "generatePDFdoc"
}

task generateHTMLdoc(type: Zip, dependsOn: "runDoxygen") {
    inputs.dir "build/doc/gen/html"
    outputs.files "build/doc/TGUI-doc.zip"

    baseName = "TGUI-doc"
    version = ""
    destinationDir = file("build/doc")
    from "build/doc/gen/html"
}

task generatePDFdoc(type: Exec, dependsOn: "runDoxygen") {
    onlyIf {
        isCommandAvailable("pdflatex") && isCommandAvailable("make")
    }

    inputs.dir "build/doc/gen/latex"
    outputs.files "build/doc/TGUI-doc.pdf"

    doFirst {
        def log = file("build/tmp/generatePDFdoc/output.txt")
        log.getParentFile().mkdirs()
        standardOutput = new FileOutputStream(log)
        errorOutput = standardOutput
    }

    doLast {
        copy {
            from "build/doc/gen/latex"
            into "build/doc"

            include "refman.pdf"
            rename "refman.pdf", "TGUI-doc.pdf"
        }
    }

    workingDir "build/doc/gen/latex"
    executable "make"
}

task runDoxygen(type: Exec) {
    onlyIf {
        isCommandAvailable("doxygen")
    }

    inputs.dir "src"
    inputs.files "Doxyfile"
    outputs.dirs "build/doc/gen"

    doFirst {
        def log = file("build/tmp/runDoxygen/output.txt")
        log.getParentFile().mkdirs()
        standardOutput = new FileOutputStream(log)
        file("build/doc/gen").mkdirs()
    }

    executable "doxygen"
    args "Doxyfile"
}

def isCommandAvailable(String exec) {
    if(System.getProperty("os.name").toLowerCase().contains("windows"))
        exec += ".exe"

    return Stream.of(System.getenv("PATH").split(Pattern.quote(File.pathSeparator)))
        .map({file -> Paths.get(file)})
        .anyMatch({path -> Files.exists(path.resolve(exec))});
}
